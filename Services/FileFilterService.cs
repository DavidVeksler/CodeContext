using CodeContext.Configuration;
using CodeContext.Interfaces;
using CodeContext.Utils;

namespace CodeContext.Services;

/// <summary>
/// Functional service for determining if files and directories should be filtered out during processing.
/// Uses composable predicates and immutable state.
/// </summary>
public class FileFilterService : IFileChecker
{
    private readonly FilterConfiguration _config;
    private readonly Lazy<GitIgnoreParser> _gitIgnoreParser;

    public FileFilterService(FilterConfiguration config)
    {
        _config = Guard.NotNull(config, nameof(config));
        _gitIgnoreParser = new Lazy<GitIgnoreParser>(() => GitIgnoreParser.Empty);
    }

    /// <summary>
    /// Creates a FileFilterService with a pre-loaded GitIgnoreParser.
    /// </summary>
    public FileFilterService(FilterConfiguration config, GitIgnoreParser gitIgnoreParser)
    {
        _config = Guard.NotNull(config, nameof(config));
        _gitIgnoreParser = new Lazy<GitIgnoreParser>(() => gitIgnoreParser);
    }

    public bool ShouldSkip(FileSystemInfo info, string rootPath)
    {
        Guard.NotNull(info, nameof(info));
        Guard.NotNullOrEmpty(rootPath, nameof(rootPath));

        // Compose filter predicates - each is a pure function or has well-defined side effects
        return IsReparsePoint(info)
            || ContainsIgnoredDirectory(info, rootPath)
            || (IsFile(info) && ShouldSkipFile(info, rootPath));
    }

    private static bool IsReparsePoint(FileSystemInfo info) =>
        info.Attributes.HasFlag(FileAttributes.ReparsePoint);

    private static bool IsFile(FileSystemInfo info) =>
        !info.Attributes.HasFlag(FileAttributes.Directory);

    private bool ContainsIgnoredDirectory(FileSystemInfo info, string rootPath)
    {
        var relativePath = Path.GetRelativePath(rootPath, info.FullName);
        var pathParts = relativePath.Split(Path.DirectorySeparatorChar);
        return pathParts.Any(_config.IgnoredDirectories.Contains);
    }

    private bool ShouldSkipFile(FileSystemInfo info, string rootPath) =>
        IsIgnoredFileName(info.Name)
        || ShouldSkipByExtension(info.Name)
        || IsFileTooLarge(info)
        || ShouldSkipByGitIgnore(info.FullName, rootPath)
        || IsBinaryFile(info.FullName)
        || IsGeneratedCode(info.FullName);

    private bool IsIgnoredFileName(string fileName) =>
        _config.IgnoredFiles.Contains(fileName);

    private bool IsFileTooLarge(FileSystemInfo info) =>
        info is FileInfo fileInfo && fileInfo.Length > _config.MaxFileSizeBytes;

    private bool IsBinaryFile(string filePath) =>
        FileUtilities.IsBinaryFile(filePath, _config.BinaryCheckChunkSize, _config.BinaryThreshold);

    private bool ShouldSkipByExtension(string fileName) =>
        GetExtensions(fileName).Any(_config.IgnoredExtensions.Contains);

    /// <summary>
    /// Pure function that extracts both simple and compound extensions from a filename.
    /// For "file.min.css", returns [".css", ".min.css"]
    /// </summary>
    private static IEnumerable<string> GetExtensions(string fileName)
    {
        var extension = Path.GetExtension(fileName);
        if (!string.IsNullOrEmpty(extension))
        {
            yield return extension;
        }

        // Check for compound extensions like .min.css
        var lastDotIndex = fileName.LastIndexOf('.');
        if (lastDotIndex > 0)
        {
            var secondLastDotIndex = fileName.LastIndexOf('.', lastDotIndex - 1);
            if (secondLastDotIndex >= 0)
            {
                yield return fileName[secondLastDotIndex..];
            }
        }
    }

    private bool ShouldSkipByGitIgnore(string filePath, string rootPath) =>
        GitHelper.FindRepositoryRoot(rootPath) switch
        {
            null => false,
            var repoRoot => IsIgnoredInRepository(filePath, repoRoot)
        };

    private bool IsIgnoredInRepository(string filePath, string repositoryRoot)
    {
        var parser = _gitIgnoreParser.Value;
        if (!parser.HasPatterns)
        {
            return false;
        }

        var relativePath = Path.GetRelativePath(repositoryRoot, filePath);
        return parser.IsIgnored(relativePath);
    }

    private bool IsGeneratedCode(string filePath) =>
        ReadFirstLines(filePath, _config.GeneratedCodeLinesToCheck)
            .Any(line => line.Contains("<auto-generated />"));

    /// <summary>
    /// Pure I/O function: reads first N lines from a file.
    /// Returns empty enumerable on error (isolates exception handling).
    /// </summary>
    private static IEnumerable<string> ReadFirstLines(string filePath, int count)
    {
        try
        {
            return File.ReadLines(filePath).Take(count);
        }
        catch
        {
            return Enumerable.Empty<string>();
        }
    }
}
