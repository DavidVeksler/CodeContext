using CodeContext.Configuration;
using CodeContext.Interfaces;
using CodeContext.Utils;

namespace CodeContext.Services;

/// <summary>
/// Service for determining if files and directories should be filtered out during processing.
/// </summary>
public class FileFilterService : IFileChecker
{
    private readonly FilterConfiguration _config;
    private readonly GitIgnoreParser _gitIgnoreParser;
    private bool _gitIgnoreLoaded;

    public FileFilterService(FilterConfiguration config)
    {
        _config = Guard.NotNull(config, nameof(config));
        _gitIgnoreParser = new GitIgnoreParser();
    }

    public bool ShouldSkip(FileSystemInfo info, string rootPath)
    {
        Guard.NotNull(info, nameof(info));
        Guard.NotNullOrEmpty(rootPath, nameof(rootPath));

        // Check if any parent directory is in the ignored list
        var relativePath = Path.GetRelativePath(rootPath, info.FullName);
        var pathParts = relativePath.Split(Path.DirectorySeparatorChar);

        if (pathParts.Any(_config.IgnoredDirectories.Contains))
        {
            return true;
        }

        if (info.Attributes.HasFlag(FileAttributes.Directory))
        {
            return false; // We've already checked if it's an ignored directory
        }

        // Check for ignored files
        if (_config.IgnoredFiles.Contains(info.Name))
        {
            return true;
        }

        // Check file extension
        if (ShouldSkipByExtension(info.Name))
        {
            return true;
        }

        // Check file size
        if (info is FileInfo fileInfo && fileInfo.Length > _config.MaxFileSizeBytes)
        {
            return true;
        }

        // Check gitignore patterns
        if (ShouldSkipByGitIgnore(info.FullName, rootPath))
        {
            return true;
        }

        // Check if binary
        if (FileUtilities.IsBinaryFile(info.FullName, _config.BinaryCheckChunkSize, _config.BinaryThreshold))
        {
            return true;
        }

        // Check for generated code
        if (IsGeneratedCode(info.FullName))
        {
            return true;
        }

        return false;
    }

    private bool ShouldSkipByExtension(string fileName)
    {
        var extension = Path.GetExtension(fileName);
        if (_config.IgnoredExtensions.Contains(extension))
        {
            return true;
        }

        // Check for compound extensions like .min.css
        var lastDotIndex = fileName.LastIndexOf('.');
        if (lastDotIndex > 0)
        {
            var secondLastDotIndex = fileName.LastIndexOf('.', lastDotIndex - 1);
            if (secondLastDotIndex >= 0)
            {
                var compoundExtension = fileName.Substring(secondLastDotIndex);
                if (_config.IgnoredExtensions.Contains(compoundExtension))
                {
                    return true;
                }
            }
        }

        return false;
    }

    private bool ShouldSkipByGitIgnore(string filePath, string rootPath)
    {
        if (!GitHelper.IsInRepository(rootPath))
        {
            return false;
        }

        if (!_gitIgnoreLoaded)
        {
            var gitRoot = GitHelper.FindRepositoryRoot(rootPath) ?? rootPath;
            var gitIgnorePath = Path.Combine(gitRoot, ".gitignore");
            _gitIgnoreParser.LoadFromFile(gitIgnorePath);
            _gitIgnoreLoaded = true;
        }

        if (!_gitIgnoreParser.HasPatterns)
        {
            return false;
        }

        var repositoryRoot = GitHelper.FindRepositoryRoot(rootPath) ?? rootPath;
        var relativePath = Path.GetRelativePath(repositoryRoot, filePath);
        return _gitIgnoreParser.IsIgnored(relativePath);
    }

    private bool IsGeneratedCode(string filePath)
    {
        try
        {
            var lines = File.ReadLines(filePath).Take(_config.GeneratedCodeLinesToCheck);
            return lines.Any(line => line.Contains("<auto-generated />"));
        }
        catch
        {
            return false;
        }
    }
}
