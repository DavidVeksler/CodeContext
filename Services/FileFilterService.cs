using CodeContext.Configuration;
using CodeContext.Interfaces;
using CodeContext.Utils;

namespace CodeContext.Services;

/// <summary>
/// Service for determining if files and directories should be filtered out during processing.
/// </summary>
public class FileFilterService : IFileChecker
{
    private readonly FilterConfiguration _config;
    private readonly GitIgnoreParser _gitIgnoreParser;
    private bool _gitIgnoreLoaded;

    /// <summary>
    /// Initializes a new instance of the FileFilterService class.
    /// </summary>
    /// <param name="config">The filter configuration to use.</param>
    public FileFilterService(FilterConfiguration config)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _gitIgnoreParser = new GitIgnoreParser();
    }

    /// <inheritdoc/>
    public bool ShouldSkip(FileSystemInfo info, string rootPath)
    {
        if (info == null)
        {
            throw new ArgumentNullException(nameof(info));
        }

        if (string.IsNullOrEmpty(rootPath))
        {
            throw new ArgumentException("Root path cannot be null or empty.", nameof(rootPath));
        }

        // Check if any parent directory is in the ignored list
        var relativePath = Path.GetRelativePath(rootPath, info.FullName);
        var pathParts = relativePath.Split(Path.DirectorySeparatorChar);

        if (pathParts.Any(_config.IgnoredDirectories.Contains))
        {
            return true;
        }

        if (info.Attributes.HasFlag(FileAttributes.Directory))
        {
            return false; // We've already checked if it's an ignored directory
        }

        // Check for ignored files
        if (_config.IgnoredFiles.Contains(info.Name))
        {
            return true;
        }

        // Check file extension
        if (ShouldSkipByExtension(info.Name))
        {
            return true;
        }

        // Check file size
        if (info is FileInfo fileInfo && fileInfo.Length > _config.MaxFileSizeBytes)
        {
            return true;
        }

        // Check gitignore patterns
        if (ShouldSkipByGitIgnore(info.FullName, rootPath))
        {
            return true;
        }

        // Check if binary
        if (FileUtilities.IsBinaryFile(info.FullName, _config.BinaryCheckChunkSize, _config.BinaryThreshold))
        {
            return true;
        }

        // Check for generated code
        if (IsGeneratedCode(info.FullName))
        {
            return true;
        }

        return false;
    }

    private bool ShouldSkipByExtension(string fileName)
    {
        var extension = Path.GetExtension(fileName);
        if (_config.IgnoredExtensions.Contains(extension))
        {
            return true;
        }

        // Check for compound extensions like .min.css
        var lastDotIndex = fileName.LastIndexOf('.');
        if (lastDotIndex > 0)
        {
            var secondLastDotIndex = fileName.LastIndexOf('.', lastDotIndex - 1);
            if (secondLastDotIndex >= 0)
            {
                var compoundExtension = fileName.Substring(secondLastDotIndex);
                if (_config.IgnoredExtensions.Contains(compoundExtension))
                {
                    return true;
                }
            }
        }

        return false;
    }

    private bool ShouldSkipByGitIgnore(string filePath, string rootPath)
    {
        if (!IsInGitRepository(rootPath))
        {
            return false;
        }

        if (!_gitIgnoreLoaded)
        {
            var gitIgnorePath = Path.Combine(FindGitRepoRoot(rootPath) ?? rootPath, ".gitignore");
            _gitIgnoreParser.LoadFromFile(gitIgnorePath);
            _gitIgnoreLoaded = true;
        }

        if (!_gitIgnoreParser.HasPatterns)
        {
            return false;
        }

        var gitRoot = FindGitRepoRoot(rootPath) ?? rootPath;
        var relativePath = Path.GetRelativePath(gitRoot, filePath);
        return _gitIgnoreParser.IsIgnored(relativePath);
    }

    private bool IsGeneratedCode(string filePath)
    {
        try
        {
            var lines = File.ReadLines(filePath).Take(_config.GeneratedCodeLinesToCheck);
            return lines.Any(line => line.Contains("<auto-generated />"));
        }
        catch (Exception)
        {
            // If we can't read the file, assume it's not generated code
            return false;
        }
    }

    private static bool IsInGitRepository(string path)
    {
        return FindGitRepoRoot(path) != null;
    }

    private static string? FindGitRepoRoot(string path)
    {
        var currentPath = path;
        while (!string.IsNullOrEmpty(currentPath))
        {
            if (Directory.Exists(Path.Combine(currentPath, ".git")))
            {
                return currentPath;
            }
            currentPath = Path.GetDirectoryName(currentPath);
        }

        return null;
    }
}
